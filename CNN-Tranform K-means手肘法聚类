import os
import cv2
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import font_manager  # 用于设置字体
from torch.utils.data import DataLoader, Dataset
from torchvision import transforms, models
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA  # 用于降维
from sklearn.manifold import TSNE  # t-SNE 用于降维
from torchvision.models import ResNet18_Weights

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']  # 设置字体为黑体
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号

# 自定义数据集类
class ImageDataset(Dataset):
    def __init__(self, image_dir, transform=None):
        self.image_dir = image_dir
        self.image_files = [f for f in os.listdir(image_dir) if f.endswith(('png', 'jpg', 'jpeg'))]
        self.transform = transform

    def __len__(self):
        return len(self.image_files)

    def __getitem__(self, idx):
        img_name = os.path.join(self.image_dir, self.image_files[idx])
        image = cv2.imread(img_name)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        if self.transform:
            image = self.transform(image)

        return image, self.image_files[idx]

# 图像预处理
transform = transforms.Compose([
    transforms.ToPILImage(),
    transforms.Resize((64, 64)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(15),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

# CNN-Transformer 模型
class CNNTransformer(nn.Module):
    def __init__(self):
        super(CNNTransformer, self).__init__()
        
        # 使用预训练的 ResNet 作为 CNN 特征提取器
        resnet = models.resnet18(weights=ResNet18_Weights.IMAGENET1K_V1)
        self.cnn = nn.Sequential(*list(resnet.children())[:-1])  # 移除全连接层
        
        # Transformer 设置
        self.transformer = nn.Transformer(
            d_model=512,          # 变换器的隐藏层大小
            nhead=8,              # 多头注意力的头数
            num_encoder_layers=6,  # 编码器层数
            num_decoder_layers=6,  # 解码器层数
            dim_feedforward=2048,  # 前馈网络的维度
            dropout=0.1,          # 丢弃率
        )
        
        # 最后的分类器
        self.fc = nn.Linear(512, 4)  # 4 类的输出

    def forward(self, x):
        # CNN 提取特征
        cnn_features = self.cnn(x).view(x.size(0), -1)  # 展平 CNN 输出
        
        # Transformer 处理
        transformer_output = self.transformer(cnn_features.unsqueeze(0), cnn_features.unsqueeze(0))
        
        # 最后分类
        output = self.fc(transformer_output.squeeze(0))
        return output

# 使用 PCA 或 t-SNE 进行聚类可视化，并在图形上标注聚类类别
def visualize_clusters_pca_tsne(features, labels, method='pca'):
    # 定义聚类标签，映射噪音类型
    cluster_labels = {
        0: "High-Frequency Spike Noise",  # 高频尖峰噪声
        1: "Mid-Frequency Burst Noise",   # 中频脉冲噪声
        2: "Low-Frequency Oscillatory Noise",  # 低频振荡噪声
        3: "Mid-High Frequency Periodic Oscillatory Noise"  # 中高频周期振荡噪声
    }

    if method == 'pca':
        reducer = PCA(n_components=2)
        reduced_features = reducer.fit_transform(features)
        title = 'PCA-based Clustering Visualization'
    elif method == 'tsne':
        reducer = TSNE(n_components=2, perplexity=30, n_iter=300)
        reduced_features = reducer.fit_transform(features)
        title = 't-SNE-based Clustering Visualization'
    
    # 创建颜色映射
    plt.figure(figsize=(8, 6))
    scatter = plt.scatter(reduced_features[:, 0], reduced_features[:, 1], c=labels, cmap='viridis', s=50)
    plt.colorbar(scatter)
    plt.title(title, fontsize=14)
    plt.xlabel("Component 1", fontsize=12)
    plt.ylabel("Component 2", fontsize=12)

    # 计算每个聚类的中心点
    for label in np.unique(labels):
        cluster_points = reduced_features[labels == label]  # 获取属于该聚类的点
        cluster_center = np.mean(cluster_points, axis=0)  # 计算聚类中心
        plt.text(cluster_center[0], cluster_center[1], cluster_labels[label],
                 fontsize=12, color='black', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none'))

    plt.show()



# 聚类并可视化结果，同时通过傅里叶变换分析振荡频率
def visualize_clusters(image_paths, labels, output_dir):
    cluster_labels = {
        0: "高频尖峰噪声",  # 高频尖峰噪声
        1: "中频脉冲噪声",   # 中频脉冲噪声
        2: "低频振荡噪声",  # 低频振荡噪声
        3: "中高频周期振荡噪声"  # 中高频周期振荡噪声
    }

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for i, img_path in enumerate(image_paths):
        img = cv2.imread(img_path)
        label = labels[i]
        output_path = os.path.join(output_dir, f"cluster_{label}")
        if not os.path.exists(output_path):
            os.makedirs(output_path)
        cv2.putText(img, f"{cluster_labels[label]}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2, cv2.LINE_AA)
        cv2.imwrite(os.path.join(output_path, os.path.basename(img_path)), img)

        # 读取波形并绘制波形
        waveform = img.mean(axis=0)  # 简单平均得到波形
        plt.figure()
        plt.title(f"Cluster {label}: {cluster_labels[label]}")
        plt.plot(np.arange(len(waveform)), waveform)  # 简单绘制波形
        plt.savefig(os.path.join(output_path, f"waveform_cluster_{label}.png"))
        plt.close()

        # 进行傅里叶变换，分析振荡频率
        fft_result = np.fft.fft(waveform)
        freqs = np.fft.fftfreq(len(fft_result))
        magnitude = np.abs(fft_result)

        # 绘制频谱图
        plt.figure()
        plt.title(f"Cluster {label} FFT Spectrum")
        plt.plot(freqs, magnitude)
        plt.xlabel("Frequency")
        plt.ylabel("Magnitude")
        plt.savefig(os.path.join(output_path, f"fft_spectrum_cluster_{label}.png"))
        plt.close()

# 保存聚类结果到 CSV 文件
def save_cluster_results_to_csv(image_paths, labels, output_csv):
    df = pd.DataFrame({
        'image_path': image_paths,
        'cluster': labels
    })
    df.to_csv(output_csv, index=False)
    print(f"聚类结果已保存到 {output_csv}")

# 主函数
def main():
    image_dir = r'E:\julei\zaosheng\result'  # 替换为您的图片文件夹路径
    output_dir = r'E:\julei\op'  # 替换为保存聚类结果的文件夹路径
    output_csv = r'E:\julei\opcsv\result.csv'

    # 加载数据集
    dataset = ImageDataset(image_dir, transform=transform)
    dataloader = DataLoader(dataset, batch_size=32, shuffle=False)

    # 初始化 CNN-Transformer 模型
    model = CNNTransformer()
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)
    model.eval()

    features = []
    image_paths = []

    # 提取特征
    with torch.no_grad():
        for images, img_names in dataloader:
            images = images.to(device)
            outputs = model(images)
            features.append(outputs.cpu().numpy())
            image_paths.extend([os.path.join(image_dir, img_name) for img_name in img_names])

    features = np.vstack(features)

    # 标准化特征
    scaler = StandardScaler()
    features = scaler.fit_transform(features)

    # 使用KMeans聚类，固定为4类
    kmeans = KMeans(n_clusters=4, random_state=0)
    labels = kmeans.fit_predict(features)

    # 保存聚类结果到CSV
    save_cluster_results_to_csv(image_paths, labels, output_csv)

    # 使用 PCA 或 t-SNE 可视化聚类
    visualize_clusters_pca_tsne(features, labels, method='pca')  # 使用 PCA 可视化
    visualize_clusters_pca_tsne(features, labels, method='tsne')  # 使用 t-SNE 可视化

    # 可视化并进行傅里叶变换分析
    visualize_clusters(image_paths, labels, output_dir)

if __name__ == "__main__":
    main()
